// Generated by CoffeeScript 1.8.0
'use strict';
var GameProtocol, SecurityProtocol,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

SecurityProtocol = global.resolver.load('SecurityProtocol', 'Communication/SecurityProtocol');

GameProtocol = (function() {
  function GameProtocol(server, socket) {
    this.server = server;
    this.socket = socket;
    this.criptoAnalyzer = new SecurityProtocol(this.server, this.socket);
    this.socket.on('error', (function(_this) {
      return function(e) {
        var _ref;
        if (_ref = e.code, __indexOf.call(global.constants.ERRORS, _ref) >= 0) {
          return console.log("error handled: " + e);
        }
      };
    })(this));
    this.server.on('error', (function(_this) {
      return function(e) {
        var _ref;
        if (_ref = e.code, __indexOf.call(global.constants.ERRORS, _ref) >= 0) {
          return console.log("error handled: " + e);
        }
      };
    })(this));
    this.socket.on('data', (function(_this) {
      return function(chunk) {
        var e, encryptedChunk;
        encryptedChunk = '';
        try {
          if (chunk.length > 300) {
            console.log("received " + chunk + "\n*********************************");
            encryptedChunk = _this.criptoAnalyzer.decrypt(chunk.toString());
            console.log(encryptedChunk);
          } else {
            _this.criptoAnalyzer.test(chunk);
          }
        } catch (_error) {
          e = _error;
          console.log(e);
        }
        return _this.socket.write(encryptedChunk || _this.criptoAnalyzer.encrypt(123));
      };
    })(this));
    this.socket.on('end', socket.end);
  }

  return GameProtocol;

})();

module.exports = GameProtocol;
